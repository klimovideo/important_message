from pydantic import BaseModel
from typing import Dict, List, Optional, Set
from datetime import datetime
import json
import os
import logging
import html
from enum import Enum

logger = logging.getLogger(__name__)

class PostCategory(str, Enum):
    """–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ—Å—Ç–æ–≤"""
    GENERAL = "general"  # –û–±—â–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
    BOOKS = "books"  # –ö–Ω–∏–≥–∏ –∏ –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞
    LLM = "llm"  # LLM –∏ AI
    TECH = "tech"  # –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏
    SCIENCE = "science"  # –ù–∞—É–∫–∞

class PostStatus(str, Enum):
    """–°—Ç–∞—Ç—É—Å—ã –ø–æ—Å—Ç–æ–≤ –≤ –æ—á–µ—Ä–µ–¥–∏"""
    PENDING = "pending"  # –û–∂–∏–¥–∞–µ—Ç –º–æ–¥–µ—Ä–∞—Ü–∏–∏
    APPROVED = "approved"  # –û–¥–æ–±—Ä–µ–Ω
    REJECTED = "rejected"  # –û—Ç–∫–ª–æ–Ω–µ–Ω
    PUBLISHED = "published"  # –û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω

class ImportanceCriteria(BaseModel):
    """–ö—Ä–∏—Ç–µ—Ä–∏–∏ –≤–∞–∂–Ω–æ—Å—Ç–∏ —Å–æ–æ–±—â–µ–Ω–∏–π"""
    keywords_boost: List[str] = []  # –°–ª–æ–≤–∞, –ø–æ–≤—ã—à–∞—é—â–∏–µ –≤–∞–∂–Ω–æ—Å—Ç—å
    keywords_reduce: List[str] = []  # –°–ª–æ–≤–∞, —Å–Ω–∏–∂–∞—é—â–∏–µ –≤–∞–∂–Ω–æ—Å—Ç—å
    sources_boost: List[int] = []  # ID –∫–∞–Ω–∞–ª–æ–≤/—á–∞—Ç–æ–≤ —Å –ø–æ–≤—ã—à–µ–Ω–Ω–æ–π –≤–∞–∂–Ω–æ—Å—Ç—å—é
    sources_reduce: List[int] = []  # ID –∫–∞–Ω–∞–ª–æ–≤/—á–∞—Ç–æ–≤ —Å –ø–æ–Ω–∏–∂–µ–Ω–Ω–æ–π –≤–∞–∂–Ω–æ—Å—Ç—å—é
    min_message_length: int = 10  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
    max_message_length: int = 4000  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
    exclude_forwarded: bool = False  # –ò—Å–∫–ª—é—á–∞—Ç—å –ø–µ—Ä–µ—Å–ª–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    time_sensitivity: bool = True  # –£—á–∏—Ç—ã–≤–∞—Ç—å –≤—Ä–µ–º—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏

class BotConfig(BaseModel):
    """–ì–ª–æ–±–∞–ª—å–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–æ—Ç–∞"""
    admin_ids: Set[int] = set()  # ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
    publish_channel_id: Optional[int] = None  # ID –∫–∞–Ω–∞–ª–∞ –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ (–æ—Å–Ω–æ–≤–Ω–æ–π)
    publish_channel_username: Optional[str] = None  # Username –∫–∞–Ω–∞–ª–∞
    # –°–ª–æ–≤–∞—Ä—å –∫–∞–Ω–∞–ª–æ–≤ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
    category_channels: Dict[str, Dict[str, Optional[str]]] = {
        PostCategory.GENERAL: {"id": None, "username": None},
        PostCategory.BOOKS: {"id": None, "username": None},
        PostCategory.LLM: {"id": None, "username": None},
        PostCategory.TECH: {"id": None, "username": None},
        PostCategory.SCIENCE: {"id": None, "username": None}
    }
    importance_threshold: float = 0.7  # –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ –≤–∞–∂–Ω–æ—Å—Ç–∏
    importance_criteria: ImportanceCriteria = ImportanceCriteria()
    auto_publish_enabled: bool = True  # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—É–±–ª–∏–∫–∞—Ü–∏—è –≤–∞–∂–Ω—ã—Ö –ø–æ—Å—Ç–æ–≤
    require_admin_approval: bool = True  # –¢—Ä–µ–±–æ–≤–∞—Ç—å –æ–¥–æ–±—Ä–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
    created_at: datetime = datetime.now()
    updated_at: datetime = datetime.now()

class PendingPost(BaseModel):
    """–ü–æ—Å—Ç –≤ –æ—á–µ—Ä–µ–¥–∏ –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é"""
    post_id: str  # –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –ø–æ—Å—Ç–∞
    user_id: int  # ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–ø—Ä–∞–≤–∏–ª
    message_text: str  # –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
    category: PostCategory = PostCategory.GENERAL  # –ö–∞—Ç–µ–≥–æ—Ä–∏—è –ø–æ—Å—Ç–∞
    source_info: Optional[str] = None  # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∏—Å—Ç–æ—á–Ω–∏–∫–µ
    importance_score: Optional[float] = None  # –û—Ü–µ–Ω–∫–∞ –≤–∞–∂–Ω–æ—Å—Ç–∏ –ò–ò
    status: PostStatus = PostStatus.PENDING
    submitted_at: datetime = datetime.now()
    reviewed_at: Optional[datetime] = None
    reviewed_by: Optional[int] = None  # ID –∞–¥–º–∏–Ω–∞, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–ª
    admin_comment: Optional[str] = None  # –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∞–¥–º–∏–Ω–∞
    original_message_id: Optional[int] = None  # ID –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    original_chat_id: Optional[int] = None  # ID —á–∞—Ç–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞

class UserPreferences(BaseModel):
    """User preferences for message filtering"""
    user_id: int
    monitored_chats: Set[int] = set()  # Set of chat IDs to monitor
    monitored_channels: Set[int] = set()  # Set of channel IDs to monitor
    keywords: List[str] = []  # Keywords to prioritize
    exclude_keywords: List[str] = []  # Keywords to deprioritize
    can_submit_posts: bool = True  # –ú–æ–∂–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–µ–¥–ª–∞–≥–∞—Ç—å –ø–æ—Å—Ç—ã
    current_state: Optional[str] = None  # –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (userbot_join, etc.)
    created_at: datetime = datetime.now()
    updated_at: datetime = datetime.now()
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat(),
            set: list
        }

class Message(BaseModel):
    """Message data structure"""
    message_id: int
    chat_id: int
    chat_title: str
    sender_id: Optional[int] = None
    sender_name: Optional[str] = None
    text: str
    date: datetime
    importance_score: Optional[float] = None
    is_channel: bool = False
    
    def to_prompt(self) -> str:
        """Convert message to a format suitable for AI prompt"""
        source = f"–∫–∞–Ω–∞–ª '{self.chat_title}'" if self.is_channel else f"—á–∞—Ç '{self.chat_title}'"
        sender = f" –æ—Ç {self.sender_name}" if self.sender_name else ""
        return f"–°–æ–æ–±—â–µ–Ω–∏–µ{sender} –≤ {source} –≤ {self.date.strftime('%d.%m.%Y %H:%M:%S')}:\n\n{self.text}"
    
    def to_user_notification(self) -> str:
        """Format message as a notification to the user"""
        source = f"–ö–∞–Ω–∞–ª: {html.escape(self.chat_title)}" if self.is_channel else f"–ß–∞—Ç: {html.escape(self.chat_title)}"
        sender = f"\n–û—Ç: {html.escape(self.sender_name)}" if self.sender_name else ""
        importance = f"\n–û—Ü–µ–Ω–∫–∞ –≤–∞–∂–Ω–æ—Å—Ç–∏: {self.importance_score:.2f}" if self.importance_score is not None else ""
        
        return f"üîî *–í–ê–ñ–ù–û–ï –°–û–û–ë–©–ï–ù–ò–ï*\n\n{source}{sender}{importance}\n\n{html.escape(self.text)}"

class Storage:
    """Simple JSON-based storage for user preferences"""
    DB_FILE = "user_preferences.json"
    CONFIG_FILE = "bot_config.json"
    POSTS_FILE = "pending_posts.json"
    
    users: Dict[int, UserPreferences] = {}
    bot_config: BotConfig = BotConfig()
    pending_posts: Dict[str, PendingPost] = {}
    
    @classmethod
    def load_from_file(cls) -> None:
        """Load all data from JSON files"""
        cls.ensure_files_exist()
        cls.load_users()
        cls.load_config()
        cls.load_posts()
    
    @classmethod
    def ensure_files_exist(cls) -> None:
        """Ensure all required files exist with default content"""
        # Create user preferences file if not exists
        if not os.path.exists(cls.DB_FILE):
            logger.info(f"–°–æ–∑–¥–∞—é —Ñ–∞–π–ª {cls.DB_FILE}")
            with open(cls.DB_FILE, 'w', encoding='utf-8') as f:
                json.dump({}, f, ensure_ascii=False, indent=2)
        
        # Create bot config file if not exists
        if not os.path.exists(cls.CONFIG_FILE):
            logger.info(f"–°–æ–∑–¥–∞—é —Ñ–∞–π–ª {cls.CONFIG_FILE}")
            default_config = BotConfig()
            config_dict = {
                "admin_ids": list(default_config.admin_ids),
                "publish_channel_id": default_config.publish_channel_id,
                "publish_channel_username": default_config.publish_channel_username,
                "importance_threshold": default_config.importance_threshold,
                "importance_criteria": {
                    "keywords_boost": default_config.importance_criteria.keywords_boost,
                    "keywords_reduce": default_config.importance_criteria.keywords_reduce,
                    "sources_boost": default_config.importance_criteria.sources_boost,
                    "sources_reduce": default_config.importance_criteria.sources_reduce,
                    "min_message_length": default_config.importance_criteria.min_message_length,
                    "max_message_length": default_config.importance_criteria.max_message_length,
                    "exclude_forwarded": default_config.importance_criteria.exclude_forwarded,
                    "time_sensitivity": default_config.importance_criteria.time_sensitivity
                },
                "auto_publish_enabled": default_config.auto_publish_enabled,
                "require_admin_approval": default_config.require_admin_approval,
                "created_at": default_config.created_at.isoformat(),
                "updated_at": default_config.updated_at.isoformat()
            }
            with open(cls.CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config_dict, f, ensure_ascii=False, indent=2)
        
        # Create pending posts file if not exists
        if not os.path.exists(cls.POSTS_FILE):
            logger.info(f"–°–æ–∑–¥–∞—é —Ñ–∞–π–ª {cls.POSTS_FILE}")
            with open(cls.POSTS_FILE, 'w', encoding='utf-8') as f:
                json.dump({}, f, ensure_ascii=False, indent=2)
    
    @classmethod
    def load_users(cls) -> None:
        """Load user preferences from JSON file"""
        if not os.path.exists(cls.DB_FILE):
            logger.info(f"–§–∞–π–ª –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö {cls.DB_FILE} –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–∏–Ω–∞–µ–º —Å –ø—É—Å—Ç–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞")
            return
        
        try:
            with open(cls.DB_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                
            for user_id_str, user_data in data.items():
                user_id = int(user_id_str)
                # Convert sets back from lists
                if 'monitored_chats' in user_data:
                    user_data['monitored_chats'] = set(user_data['monitored_chats'])
                if 'monitored_channels' in user_data:
                    user_data['monitored_channels'] = set(user_data['monitored_channels'])
                
                # Parse datetime strings
                if 'created_at' in user_data:
                    user_data['created_at'] = datetime.fromisoformat(user_data['created_at'])
                if 'updated_at' in user_data:
                    user_data['updated_at'] = datetime.fromisoformat(user_data['updated_at'])
                
                cls.users[user_id] = UserPreferences(**user_data)
                
            logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(cls.users)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö")
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {e}")
            cls.users = {}
    
    @classmethod
    def load_config(cls) -> None:
        """Load bot configuration from JSON file"""
        if not os.path.exists(cls.CONFIG_FILE):
            logger.info(f"–§–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ {cls.CONFIG_FILE} –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")
            return
        
        try:
            with open(cls.CONFIG_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Convert admin_ids from list to set
            if 'admin_ids' in data:
                data['admin_ids'] = set(data['admin_ids'])
            
            # Parse datetime strings
            if 'created_at' in data:
                data['created_at'] = datetime.fromisoformat(data['created_at'])
            if 'updated_at' in data:
                data['updated_at'] = datetime.fromisoformat(data['updated_at'])
            
            # Parse importance criteria
            if 'importance_criteria' in data:
                data['importance_criteria'] = ImportanceCriteria(**data['importance_criteria'])
            
            cls.bot_config = BotConfig(**data)
            logger.info("–ó–∞–≥—Ä—É–∂–µ–Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–æ—Ç–∞")
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            cls.bot_config = BotConfig()
    
    @classmethod
    def load_posts(cls) -> None:
        """Load pending posts from JSON file"""
        if not os.path.exists(cls.POSTS_FILE):
            logger.info(f"–§–∞–π–ª –ø–æ—Å—Ç–æ–≤ {cls.POSTS_FILE} –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–∏–Ω–∞–µ–º —Å –ø—É—Å—Ç–æ–π –æ—á–µ—Ä–µ–¥–∏")
            return
        
        try:
            with open(cls.POSTS_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            for post_id, post_data in data.items():
                # Parse datetime strings
                if 'submitted_at' in post_data:
                    post_data['submitted_at'] = datetime.fromisoformat(post_data['submitted_at'])
                if 'reviewed_at' in post_data and post_data['reviewed_at']:
                    post_data['reviewed_at'] = datetime.fromisoformat(post_data['reviewed_at'])
                
                cls.pending_posts[post_id] = PendingPost(**post_data)
            
            logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(cls.pending_posts)} –ø–æ—Å—Ç–æ–≤ –∏–∑ –æ—á–µ—Ä–µ–¥–∏")
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ—Å—Ç–æ–≤: {e}")
            cls.pending_posts = {}
    
    @classmethod
    def save_to_file(cls) -> None:
        """Save all data to JSON files"""
        cls.save_users()
        cls.save_config()
        cls.save_posts()
    
    @classmethod
    def save_users(cls) -> None:
        """Save user preferences to JSON file with backup"""
        try:
            # –°–æ–∑–¥–∞–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é –µ—Å–ª–∏ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if os.path.exists(cls.DB_FILE):
                import shutil
                backup_file = f"{cls.DB_FILE}.bak"
                shutil.copy2(cls.DB_FILE, backup_file)
            
            data = {}
            for user_id, user in cls.users.items():
                user_dict = user.dict()
                # Convert sets to lists for JSON serialization
                user_dict['monitored_chats'] = list(user.monitored_chats)
                user_dict['monitored_channels'] = list(user.monitored_channels)
                data[str(user_id)] = user_dict
            
            with open(cls.DB_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False, default=str)
                
            logger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ {len(cls.users)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö")
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {e}")
            # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–∑ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏ –µ—Å–ª–∏ –µ—Å—Ç—å
            backup_file = f"{cls.DB_FILE}.bak"
            if os.path.exists(backup_file):
                import shutil
                shutil.copy2(backup_file, cls.DB_FILE)
                logger.info("–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ —Ä–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö")
    
    @classmethod
    def save_config(cls) -> None:
        """Save bot configuration to JSON file"""
        try:
            data = cls.bot_config.dict()
            data['admin_ids'] = list(cls.bot_config.admin_ids)
            
            with open(cls.CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False, default=str)
            
            logger.info("–°–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–æ—Ç–∞")
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
    
    @classmethod
    def save_posts(cls) -> None:
        """Save pending posts to JSON file"""
        try:
            data = {}
            for post_id, post in cls.pending_posts.items():
                data[post_id] = post.dict()
            
            with open(cls.POSTS_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False, default=str)
            
            logger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ {len(cls.pending_posts)} –ø–æ—Å—Ç–æ–≤ –≤ –æ—á–µ—Ä–µ–¥–∏")
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Å—Ç–æ–≤: {e}")
    
    @classmethod
    def get_user(cls, user_id: int) -> UserPreferences:
        """Get user preferences, create if not exists"""
        if user_id not in cls.users:
            cls.users[user_id] = UserPreferences(user_id=user_id)
            cls.save_users()
        return cls.users[user_id]
    
    @classmethod
    def update_user(cls, preferences: UserPreferences) -> None:
        """Update user preferences and save to file"""
        preferences.updated_at = datetime.now()
        cls.users[preferences.user_id] = preferences
        cls.save_users()
    
    @classmethod
    def delete_user(cls, user_id: int) -> bool:
        """Delete user preferences"""
        if user_id in cls.users:
            del cls.users[user_id]
            cls.save_users()
            return True
        return False
    
    @classmethod
    def get_all_users(cls) -> Dict[int, UserPreferences]:
        """Get all users"""
        return cls.users.copy()
    
    @classmethod
    def get_users_monitoring_chat(cls, chat_id: int) -> List[UserPreferences]:
        """Get all users monitoring a specific chat"""
        return [user for user in cls.users.values() if chat_id in user.monitored_chats]
    
    @classmethod
    def get_users_monitoring_channel(cls, channel_id: int) -> List[UserPreferences]:
        """Get all users monitoring a specific channel"""
        return [user for user in cls.users.values() if channel_id in user.monitored_channels]
    
    @classmethod
    def update_config(cls, config: BotConfig) -> None:
        """Update bot configuration"""
        config.updated_at = datetime.now()
        cls.bot_config = config
        cls.save_config()
    
    @classmethod
    def is_admin(cls, user_id: int) -> bool:
        """Check if user is admin"""
        return user_id in cls.bot_config.admin_ids
    
    @classmethod
    def add_admin(cls, user_id: int) -> None:
        """Add admin"""
        cls.bot_config.admin_ids.add(user_id)
        cls.save_config()
    
    @classmethod
    def remove_admin(cls, user_id: int) -> None:
        """Remove admin"""
        cls.bot_config.admin_ids.discard(user_id)
        cls.save_config()
    
    @classmethod
    def add_pending_post(cls, post: PendingPost) -> None:
        """Add post to pending queue"""
        cls.pending_posts[post.post_id] = post
        cls.save_posts()
    
    @classmethod
    def get_pending_post(cls, post_id: str) -> Optional[PendingPost]:
        """Get pending post by ID"""
        return cls.pending_posts.get(post_id)
    
    @classmethod
    def update_post_status(cls, post_id: str, status: PostStatus, admin_id: Optional[int] = None, comment: Optional[str] = None) -> bool:
        """Update post status"""
        if post_id in cls.pending_posts:
            post = cls.pending_posts[post_id]
            post.status = status
            post.reviewed_at = datetime.now()
            post.reviewed_by = admin_id
            post.admin_comment = comment
            cls.save_posts()
            return True
        return False
    
    @classmethod
    def get_pending_posts(cls, status: Optional[PostStatus] = None) -> List[PendingPost]:
        """Get pending posts, optionally filtered by status"""
        if status:
            return [post for post in cls.pending_posts.values() if post.status == status]
        return list(cls.pending_posts.values())
    
    @classmethod
    def delete_post(cls, post_id: str) -> bool:
        """Delete post from queue"""
        if post_id in cls.pending_posts:
            del cls.pending_posts[post_id]
            cls.save_posts()
            return True
        return False

# Initialize storage on import
Storage.load_from_file() 